# Multi-Input Multiplication Layer

多入力乗算レイヤ（Multi-Input Multiplication Layer）の実装比較ドキュメントです。
本リポジトリでは、誤差逆伝播法における乗算ノードを $N$ 個の入力に拡張した際、計算効率と安全性を比較するために2つの異なるアプローチ（Main / Main2）を提供しています。

## 実装クラスの概要

### 1\. Main: 概念実装 (MulLayerGeneral)

逆伝播の定義である「自分以外のすべての入力の積」を、二重ループを用いて忠実に実装したクラスです。

  * **特徴**: アルゴリズムが単純で直感的。
  * **課題**: 入力数 $N$ に対して計算量が $O(N^2)$ となり、入力が増加すると処理速度が著しく低下する。

### 2\. Main2: 最適化実装 (MulLayerOptimized)

数学的な性質を利用し、ループ回数を削減した実用向けの実装クラスです。

  * **特徴**: 全体の積を求めてから除算を行う手法を採用（ゼロ除算対策済み）。
  * **利点**: 入力数 $N$ に対して計算量が $O(N)$ であり、入力数が大規模になっても高速に動作する。

## 設計とアルゴリズムの比較

| 項目 | Main (General) | Main2 (Optimized) |
| :--- | :--- | :--- |
| **計算アプローチ** | 毎回「自分以外」を探索して乗算 | 「全体の積」を求めてから除算 |
| **計算量 (Time Complexity)** | **$O(N^2)$** | **$O(N)$** |
| **ループ構造** | 二重ループ (Nested Loop) | 単一ループ (Single Loop) |
| **スケーラビリティ** | 低い (入力数が増えると遅い) | 高い (入力数に比例) |

## Main2 (Optimized) の詳細設計

Main2では、$O(N)$ の高速性を維持しつつ、除算アプローチの致命的な欠点である「ゼロ除算 (Zero Division Error)」を回避するため、入力に含まれる `0` の個数に応じた条件分岐を実装しています。

### 計算ロジック

入力値に含まれる `0` の数（Zero Count）をカウントし、以下の3パターンに分岐します。

#### ケースA: `0` が含まれない場合 (Zero Count = 0)

最も標準的なケースです。

1.  全入力の積 ($P_{total}$) を計算します。
2.  各要素 $x_i$ の勾配 $dx_i$ を、以下の式で一括計算します。
    $$dx_i = \text{dout} \times \frac{P_{total}}{x_i}$$

<!-- end list -->

  * **結果**: 高速な除算により全要素の勾配を算出。

#### ケースB: `0` が1つだけ含まれる場合 (Zero Count = 1)

`0` である要素の勾配計算においてのみ、ゼロ除算のリスクが発生するため、個別に処理します。

1.  `0` である要素 ($x_k$) の勾配: 他のすべての要素（非ゼロ）の積を計算して代入します。
2.  `0` 以外の要素 ($x_i$) の勾配: 「自分以外の積」の中に必ず $x_k (=0)$ が含まれるため、勾配は `0` となります。

<!-- end list -->

  * **結果**: $x_k$ のみ値を持ち、他はすべて `0`。

#### ケースC: `0` が2つ以上含まれる場合 (Zero Count $\ge$ 2)

どの要素にとっても、「自分以外の積」の中に残りの `0` が少なくとも1つ含まれる状態です。

  * **結果**: 計算を行うことなく、全要素の勾配を `0` とします。

## 使用方法

```python
# 最適化版（推奨）の使用例
layer = MulLayerOptimized()

# 順伝播
# 任意の数の引数を許容します
out = layer.forward(2.0, 3.0, 4.0)

# 逆伝播
dx = layer.backward(1.0)
```

## 結論

  * 学習目的でアルゴリズムの定義を確認する場合は **Main (MulLayerGeneral)** を参照してください。
  * 実務での利用や、3つ以上の入力を扱う場合は、計算効率と安定性に優れた **Main2 (MulLayerOptimized)** の使用を推奨します。
